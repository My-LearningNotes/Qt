The Meta-Object System
======================

Qt's meta-object system provides the signals and slots mechanism for inter-object communication, run-time type information, and the dynamic property system.

Meta-Object System(元对象系统)，是Qt对标准C++对象的一种扩展，提供了信号槽机制，运行时类型信息和动态属性系统。

The meta-object system is based on three things:

-  The ``QObject`` class provides a base class for objects that can take advantage of the meta-object system.
-  The ``Q_OBJECT`` macro inside the private section of the class declaration is used to enable meta-object features, such as dynamic properties, signals and slots.
-  The **Meta-Object Compiler(moc)** supplies each ``QObject`` subclass with the necessary code to implement meta-object features.

In addition to providing the signals and slot mechanism for communication between objects(the main reason for introducing the system), 
the **meta-object code** provides the following additional features:

-  ``QObject::metaObject()`` returns the associated meta-object for the class.
-  ``QMetaObject::className()`` returns the class name as a string at run-time, without requiring native run-time type information(RTTI) support through the C++ compiler.
-  ``QObject::inherits()`` function returns whether an object is an instance of a class that inherits a specified class within the ``QObject`` inheritance tree.
-  ``QObject::tr()`` and ``QObject::trUtf8()`` translate strings for internationalization.
-  ``QObject::setProperty()`` and ``QObject::property()`` dynamically set and get properties by name.
-  ``QObject::newInstance()`` constructs a new instance of the class.


``QObject``
-----------

``QObject``\ 是Qt对象模型的核心.

如果我们自定义的类要使用信号槽，运行时类型信息和动态属性系统等元对象系统的特性，那么就要继承\ ``QObject``.


``Q_OBJECT``
------------

The ``Q_OBJECT`` macro must appear in the private section of a class definition that declares its own signals and slots or that uses others services provided by Qt's meta-object system.

如果在一个类中定义了信号槽，或者使用了其它元对象系统的特性，那么在该类的定义中必须包含\ ``Q_OBJECT``\ 宏，且声明在private部分。

For example:

.. code-block:: cpp
    :emphasize-lines: 3, 5

    #include <QObject>

    class Counter : public QObject
    {
    	Q_OBJECT
   	
    public:
        Counter() {m_value = 0;}
   	    int value() const {return m_value};
   	
    public slots:
   	    void setValue(int value);
   	
    signals:
   	    void valueChanged(int newValue);
   	
    private:
   	    int m_value;
    }

This macro requires the class to be a subclass of ``QObject``.


``Q_OBJECT``\ 宏的作用
~~~~~~~~~~~~~~~~~~~~~~

A doc related to ``moc`` :

    The Meta-Object Compiler, moc, is the program that handles Qt's C++ extensions.

    The moc tool reads a **C++ header file**. 
    If it finds one or more class declarations that contains the ``Q_OBJECT`` macro, it produces a C++ source file containing the meta-object code for those classes. 
    Among other things, meta-object code is required for the signals and slots mechanism, the run-time type information, and the dynamic property system.

``moc``\ 读取\ **C++头文件**\ ，如果发现其中的类定义中包含有\ ``Q_OBJECT``\ 宏，则\ ``moc``\ 就会对这些类进行扩展，为其增加元对象代码，并生成一个新的C++源文件。
Qt的信号槽机制，运行时类型信息和动态属性系统，都依赖这些元对象代码。

Another doc on Signals and Slots:

    All classes that contain signals or slots must mention ``Q_OBJECT`` at the top of their declaration. They must also derive(directly or indirectly) from ``QObject``.

When we want to make connection between signal and slot, we actually do it with ``QObject`` scope:

.. code-block:: cpp

    QObject::connect(sender, signal, receiver, slot);


Is ``Q_OBJECT`` macro always needed?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Actually, the ``Q_OBJECT`` macro is only required if meta-object code has to be produced by the ``moc`` tool in order to use the signals and slots mechanism, 
the run-time type information, the dynamic property system and translating features for internationlization.

While it is possible to use ``QObject`` as a base class without the Q Q_OBJECT macro and without meta object code, 
neither signals and slots nor the other features descirbed here will be available if the Q_OBJECT macro is not used.

**It is strongly recommended to use Q_OBJECT for every subclass of QObject whether or not they actually use the features listed above.**


``moc``\ (Meta-Object Compiler)
-------------------------------

The Meta-Object Compiler(moc, 元对象编译器) is the program that handles Qt's C++ extensions.

The moc tool reads a C++ header file. 
If it finds one or more class declarations that contains the ``Q_OBJECT`` macro, it produces a C++ source file containing the meta-object code for those classes. 
Among other things, meta-object code is required for the signals and slots mechanism, the run-time type information, and the dynamic property system.

The C++ source file generated by moc must be compiled and linked with the implementation of the class.

If you use qmake to create your makefiles, build rules will be included that call the moc when requied, so you will not need to use the moc directly.

``moc``\ 扩展的元对象代码，是完全使用标准C++实现的，所以扩展之后的源文件，可以使用标准的C++编译器进行编译。

如果原始的头文件的名称为\ ``xxx.h``\ ，\ ``moc``\ 扩展后生成的源文件的名称为: ``moc_xxx.cpp``\ .
例如, 头文件为foo.h，\ ``moc``\ 扩展后的源文件为moc_foo.h


一些需要注意的问题
------------------

-  **在头文件中声明类**

如果一个自定义的类要使用Qt的元对象系统的特性，该类需要继承\ ``QObject``\ ，并在类的声明中定义\ ``Q_OBJECT``\ 宏。

``moc``\ 读取头文件，如果发现头文件中定义的类包含有\ ``Q_OBJECT``\ 宏，
则\ ``moc``\ 会对该类进行扩展，为其增加元对象代码，生成一个新的名称类似\ ``moc_xxx.cpp``\ 的源文件，将该源文件和类的实现文件一起编译/链接。

**需要注意，moc只读取头文件，对头文件中包含Q_OBJECT宏的类进行扩展，所以需要在一个头文件中声明类，而不能在实现文件中声明。**

如果类的声明是在头文件中定义，则\ ``moc``\ 不会对该类进行扩展，就不会为其添加元对象代码，这样在编译时就会报错。
在使用信号槽时，就会报类似\ ``undefined reference to xxx``\ 的错误。

例如，在main.cpp中定义两个类，并连接它们的信号槽:

.. code-block:: cpp

    #include <QApplication>
    #include <QObject>
    #include <QDebug>

    class A : public QObject
    {
        Q_OBJECT

    signals:
        void finished();
    };

    class B : public QObject
    {
        Q_OBJECT

    public slots:
        void onFinished()
        {
            qDebug() << "Finished\n";
        }
    };

    int main(int argc, char *argv[])
    {
        QApplication app(argc, argv);

        A a;
        B b;
        QObject::connect(&a, SIGNAL(finished()), &b, SLOT(onFinished()));

        return app.exec();
    }    
    
上面的代码，在编译时会报类似下面的错误:

.. code-block:: text

    main.o: In function `A::A()':
    /tmp/build-untitled-Desktop_Qt_5_14_2_GCC_64bit-Debug/../untitled/main.cpp:5: undefined reference to `vtable for A'
    main.o: In function `B::B()':
    /tmp/build-untitled-Desktop_Qt_5_14_2_GCC_64bit-Debug/../untitled/main.cpp:13: undefined reference to `vtable for B'
    main.o: In function `A::~A()':
    /tmp/build-untitled-Desktop_Qt_5_14_2_GCC_64bit-Debug/../untitled/main.cpp:5: undefined reference to `vtable for A'
    main.o: In function `B::~B()':
    /tmp/build-untitled-Desktop_Qt_5_14_2_GCC_64bit-Debug/../untitled/main.cpp:13: undefined reference to `vtable for B'
    collect2: error: ld returned 1 exit status
    Makefile:277: recipe for target 'untitled' failed
    make: *** [untitled] Error 1

报错的原因，是类A和B是在实现文件(\*.cpp文件)中定义的, ``moc``\ 不会对实现文件中的类定义进行扩展, 不会为其添加元对象代码, 因而元对象系统的特性(信号槽，运行时类型信息，动态属性系统)是无法使用的。

为了解决这个问题，需要把类A和B在头文件中声明, ``moc``\ 能对头文件中定义的类进行扩展. 

